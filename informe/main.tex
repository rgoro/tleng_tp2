\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Informe TL}
\date{Julio 2015}

\usepackage{natbib}
\usepackage{graphicx}
\usepackage{caratula}
\usepackage[spanish]{babel}

\begin{document}

\newcommand{\num}{\textit{\textbf{num}}}
\newcommand{\var}{\textit{\textbf{constante}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%			INICIO DE CARÁTULA			%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\include{caratula}

\materia{Teor\'ia de Lenguajes}
\submateria{Primer Cuatrimestre de 2015}
\titulo{Trabajo Práctico 2}

\grupo{Grupo Estado Final}
\integrante{Gorojovsky, Román}{530/02}{rgorojovsky@gmail.com}
\integrante{Lazzaro, Leonardo}{147/05}{lazzaroleonardo@gmail.com}

\begin{titlepage}
\maketitle
\thispagestyle{empty}
\end{titlepage} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				FIN DE CARÁTULA			%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Introducción}
El trabajo consiste en implementar un programa que tome un archivo escrito en el lenguaje Musileng,
definido por la cátedra, y convertirlo en un archivo midi, pasando por un lenguaje intermedio que es
interpretado por el programa \emph{midicomp} para generar finalmente el archivo midi.

El problema, entonces puede dividirse en tres subproblemas: 

\begin{itemize}
	\item Convertir la descripción del lenguaje Musileng en una gramática bien definida.
	\item Aprender a usar alguna biblioteca preexistente para convertir esa gramática en código
	\item Convertir la salida del \emph{parser} creado en los dos pasos anteriores en el lenguaje de
		\emph{midicomp}
\end{itemize}

\section*{Decisiones tomadas}
Se eligió usar \emph{PLY} debido a nuestro mejor manejo del lenguaje \emph{Python} y se usó como
esqueleto del trabajo el código presentado en clase:

\begin{itemize}
	\item \texttt{lexer\_rules.py} contiene las definiciones y reglas de tokens
	\item \texttt{lexer.py} es el código de ejecución del \emph{lexer} (usado principalmente para
		testeo.
	\item \texttt{parser\_rules} contiene la definición de la gramática
	\item \texttt{expressions.py} contiene los objetos que se crean a partir del análisis sintáctico.
	\item \texttt{parser.py} es el código de ejecución del \emph{parser}
\end{itemize}

Como se verá en la sección que detalla la implementación, la conversión de objetos al lenguaje
\emph{midicomp} está implementada dentro de los objetos de \texttt{expressions.py}, usando patrones
de programación orientada a objetos.

\pagebreak
\section*{Gramática}
Se define la siguiente gramática, para cuya definición se priorizó la simplicidad en la construcción
de los objetos que luego se usarán para generar el archivo \emph{midicomp} por sobre la legibilidad
de la gramática. En general se pusieron los terminales (puntos y coma, llaves de cierre) en las
producciones ``de más afuera''.

Notamos en negrita los tokens y en negrita bastardilla los tokens con algún valor,
definidos más abajo.
$\\$

\fbox{
	\begin{minipage}{33em}
		Musileng $\rightarrow$ DefTempo DefCompas Constantes Voces\\
		DefTempo $\rightarrow$ \textbf{\#tempo} Duracion \num\\
		DefCompas $\rightarrow$ \textbf{\#compas} \num\textbf{/}\num\\
		Constantes $\rightarrow$ $\lambda$ $|$ constante \textbf{;} constantes\\
		Constante $\rightarrow$ \textbf{const} \var \textbf{ =} \num\\
		Voces $\rightarrow$ Voz \textbf{\}} $|$ Voz \textbf{\}} Voces\\
		Voz $\rightarrow$ \textbf{Voz (}Var\textbf{) \}} ListaCompases\\
		ListaCompases $\rightarrow$ ListaCompases CompORepe\\
		CopmORepe $\rightarrow$ Compases $|$ Repetir\\
		Repetir $\rightarrow$ \textbf{repetir (}\num \textbf{) \{} Compases \textbf{\}}\\
		Compases $\rightarrow$ Compas \textbf{\}} $|$ Compas \textbf{\}} Compases\\
		Compas $\rightarrow$ \textbf{compas \{} Figuras\\
		Figuras $\rightarrow$ Figura \textbf{;} $|$ Figura \textbf{;} Figuras\\
		Figura $\rightarrow$ Nota $|$ Silencio\\
		Nota $\rightarrow$ \textbf{nota (}\textit{\textbf{altura}}\textbf{,} Var\textbf{,} \textit{\textbf{duracion}}\textbf{)}\\
		Silencio $\rightarrow$ \textbf{silencio (}\textit{\textbf{duracion}}\textbf{)}\\
		Var $\rightarrow$ \var $|$ \num
	\end{minipage}
}

$\\$
Los tokens con valor son:\\

\fbox{
	\begin{minipage}{33em}
		\textit{\textbf{num}} = 0$|$[1-9][0-9]*\\
		\textit{\textbf{duracion}} = (redonda$|$blanca$|$negra$|$corchea$|$semicorchea$|$fusa$|$semifusa)(.)?\\
		\textit{\textbf{altura}} = (do$|$re$|$mi$|$fa$|$sol$|$la$|$si)(-$|$+)?\\
		\textit{\textbf{constante}} = [a-zA-Z]+
	\end{minipage}
}

$\\$

La gramática que se implementa en \texttt{parser\_rules.py} tiene una pequeña diferencia con
esta: no existe el no terminal ``ComoORepe'', que se agregó acá para simplificar la lectura, pero
está implementado directamente en la lista de compases.

\section*{Implementación}
\subsection*{Estructura}
El lenguaje se representa con una combinación de objetos y listas de estos objetos.  Como se verá
más adelante, estos objetos tienen métodos para la validación semántica del archivo y para la
conversión a \emph{midicomp}.

Un archivo parseado queda en un objeto \texttt{Musileng}\footnotemark[1] que es una tupla \texttt{(DefTempo,
DefCompas, [Constantes] [Voces])}, y que se crea al reconocer la primer producción.
\texttt{DefTempo} y \texttt{DefCompas} tienen la información correspondiente a las siguientes dos
producciones; las constantes se toman como una lista de \texttt{(nombre, valor)} y se convierten en
un diccionario en el moment de construír el \texttt{Musileng}; y finalmente viene la lista de voces
con el resto de la información.

\

Una voz, representada en la clase \texttt{Voz}, consiste en la identificación del instrumento y una
lista de compases.  Los \texttt{repetir (N)} se implementan en el momento del parseo (en
\texttt{parser\_rules.py} en vez de \texttt{expressions.py}) generando N veces la lista interna de
compases.  Cada \texttt{Compas} consiste en una lista de objetos \texttt{Figura}, que pueden ser
de la subclase \texttt{Nota} o \texttt{Silencio}.

Para definir las figuras (y también para las definiciones de los compases y del tempo) hay dos
clases: \texttt{Duracion} y \texttt{Altura}, que representan respectivamente el ritmo (redonda,
blanca, negra, con o sin puntillo, etc.) y la altura (do, re, mi, sostenido, bemol, etc.) de cada
figura.  Obviamente los silencios sólo tienen duración.

\subsection*{Validación}
La validación de la ``partitura'' se hace en forma \emph{top-down} llamando a una colección de
métodos \texttt{validar} que levantan una excepción con un mensaje (bastante) descriptivo cuando
detectan un error.  En la clase \texttt{Musileng}, se llama al \texttt{validar()} de cada una de las
voces, pasándoles la definición del compás esperado\footnotemark[2], más un número de voz, usado
para los mensajes de error.  Este método hace el pasamanos de esta información, más un número de
compás, también para los mensajes de error.

El \texttt{validar()} de cada compás hace la suma de las duraciones de sus figuras y la compara con
la duración esperada por la definición de compás.  Cada objeto \texttt{Duracion} ``sabe'' cuál es su
duración numérica: 1 para las redondas, 1/2 para las blancas, 1/4 para las negras, etc.
multiplicado por 1.5 en caso de haber puntillo.  El \texttt{Compas} levana una excepción si la suma
es mayor o menor a lo esperado.

\footnotetext[2]{Se implementó la verificación de que todas las voces tengan la misma cantidad de
	compases, pero dado que uno de los ejemplos de la cátedra viola esta regla, la verificación
	quedó comentada}

\subsection*{Conversión a formato \emph{midicomp}}
Una vez más, la implementación de esta tarea queda repartida en diversas clases, en las funciones
\texttt{get\_midicomp()}.  La clase \texttt{Musileng} lo único que sabe hacer es escribir el header

\section*{Uso del programa}

\section*{Tests y ejemplos}


\end{document}
